import { app, BrowserWindow, ipcMain, shell, Menu } from 'electron';
import * as pty from 'node-pty';
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import pidusage from 'pidusage';
import { exec } from 'child_process';
import { promisify } from 'util';
import { WorkspaceData, WorkspaceMetadata } from './types/workspace';
import { SettingsManager } from './services/SettingsManager';
import { AppSettings } from './types/settings';

const execAsync = promisify(exec);

// Request macOS Automation permissions proactively
const requestAutomationPermissions = async (): Promise<void> => {
  // Only run on macOS
  if (process.platform !== 'darwin') {
    return;
  }

  try {
    // Run a harmless osascript command that requires Automation permission
    // This will trigger the macOS permission prompt if not already granted
    await execAsync('osascript -e \'tell application "System Events" to return name\'');
    console.log('Automation permissions: granted or prompted');
  } catch (error) {
    // Permission denied or not yet granted
    // The error will be -1743 if permission is denied
    console.log('Automation permissions: awaiting user approval');
    // Don't block app startup - user can grant permission later
  }
};

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Store PTY instances for multiple terminals
const ptyProcesses = new Map<string, pty.IPty>();

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development mode only
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  // Setup application menu
  setupMenu(mainWindow);
};

const setupMenu = (mainWindow: BrowserWindow): void => {
  const isMac = process.platform === 'darwin';

  const template: Electron.MenuItemConstructorOptions[] = [
    // App menu (macOS only)
    ...(isMac ? [{
      label: app.name,
      submenu: [
        { role: 'about' as const },
        { type: 'separator' as const },
        {
          label: 'Settings...',
          accelerator: 'Cmd+,',
          click: () => {
            mainWindow.webContents.send('menu:open-settings');
          }
        },
        { type: 'separator' as const },
        { role: 'services' as const },
        { type: 'separator' as const },
        { role: 'hide' as const },
        { role: 'hideOthers' as const },
        { role: 'unhide' as const },
        { type: 'separator' as const },
        { role: 'quit' as const }
      ]
    }] : []),
    // File menu
    {
      label: 'File',
      submenu: [
        ...(!isMac ? [{
          label: 'Settings...',
          accelerator: 'Ctrl+,',
          click: () => {
            mainWindow.webContents.send('menu:open-settings');
          }
        },
        { type: 'separator' as const }] : []),
        isMac ? { role: 'close' as const } : { role: 'quit' as const }
      ]
    },
    // Edit menu
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' as const },
        { role: 'redo' as const },
        { type: 'separator' as const },
        { role: 'cut' as const },
        { role: 'copy' as const },
        { role: 'paste' as const },
        ...(isMac ? [
          { role: 'pasteAndMatchStyle' as const },
          { role: 'delete' as const },
          { role: 'selectAll' as const }
        ] : [
          { role: 'delete' as const },
          { type: 'separator' as const },
          { role: 'selectAll' as const }
        ])
      ]
    },
    // View menu
    {
      label: 'View',
      submenu: [
        // Only include reload options in development mode
        ...(process.env.NODE_ENV === 'development' ? [
          { role: 'reload' as const },
          { role: 'forceReload' as const },
          { type: 'separator' as const }
        ] : []),
        { role: 'toggleDevTools' as const },
        { type: 'separator' as const },
        { role: 'resetZoom' as const },
        { role: 'zoomIn' as const },
        { role: 'zoomOut' as const },
        { type: 'separator' as const },
        { role: 'togglefullscreen' as const }
      ]
    },
    // Window menu
    {
      label: 'Window',
      submenu: [
        { role: 'minimize' as const },
        { role: 'zoom' as const },
        ...(isMac ? [
          { type: 'separator' as const },
          { role: 'front' as const },
          { type: 'separator' as const },
          { role: 'window' as const }
        ] : [
          { role: 'close' as const }
        ])
      ]
    }
  ];

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu);
};

// Setup IPC handlers for terminal - must be before window creation
const setupTerminalHandlers = () => {
  // Determine shell based on OS
  let shellPath = process.platform === 'win32' ? 'powershell.exe' : process.env.SHELL || '/bin/zsh';

  // Validate shell exists
  if (process.platform !== 'win32') {
    const commonShells = [shellPath, '/bin/zsh', '/bin/bash', '/bin/sh'];
    shellPath = '';
    for (const testShell of commonShells) {
      if (fs.existsSync(testShell)) {
        shellPath = testShell;
        break;
      }
    }
    if (!shellPath) {
      shellPath = '/bin/sh'; // Ultimate fallback
    }
  }

  // Helper function to parse mason escape sequences from terminal output
  const parseMasonCommand = (data: string): { command: string; path: string } | null => {
    // Match OSC 1337 escape sequence: ESC ] 1337 ; MasonCommand=new-group ; Path=<path> BEL
    const match = data.match(/\x1b\]1337;MasonCommand=([^;]+);Path=([^\x07\x1b]+)[\x07\x1b]/);
    if (match) {
      return { command: match[1], path: match[2] };
    }
    return null;
  };

  // Helper function to strip mason escape sequences from output
  const stripMasonCommands = (data: string): string => {
    return data.replace(/\x1b\]1337;MasonCommand=[^;]+;Path=[^\x07\x1b]+[\x07\x1b]/g, '');
  };

  // Create terminal process
  ipcMain.handle('terminal:create', (_, terminalId: string, workingDir: string) => {
    // Clean up existing process if it exists
    if (ptyProcesses.has(terminalId)) {
      ptyProcesses.get(terminalId)?.kill();
      ptyProcesses.delete(terminalId);
    }

    // Expand ~ to home directory
    let actualWorkingDir = workingDir;
    if (workingDir === '~' || workingDir.startsWith('~/')) {
      const home = os.homedir();
      if (workingDir === '~') {
        actualWorkingDir = home;
      } else {
        actualWorkingDir = home + workingDir.substring(1);
      }
    }

    // Verify the directory exists and is accessible
    if (!fs.existsSync(actualWorkingDir)) {
      // Fallback to home directory
      actualWorkingDir = os.homedir();
    }

    try {
      // Prepare environment with PROMPT_COMMAND or precmd for bash/zsh
      const env = { ...(process.env as { [key: string]: string }) };
      env.COLORTERM = 'truecolor';

      // For bash/zsh, we'll use shell arguments to source the mason function
      let shellArgs: string[] = [];
      if (process.platform !== 'win32') {
        // For bash/zsh, use --init-file or --rcfile to inject our function
        // We'll write the function definition and then source the normal rc file
        const initScript = `
mason() {
  if [ "$1" = "new-group" ]; then
    # Convert relative path to absolute path
    local abs_path
    if [[ "$2" = /* ]]; then
      # Already absolute
      abs_path="$2"
    else
      # Make it absolute relative to PWD
      abs_path="$(cd "$2" 2>/dev/null && pwd)" || abs_path="$PWD/$2"
    fi
    printf '\\033]1337;MasonCommand=new-group;Path=%s\\007' "$abs_path"
  elif [ "$1" = "set" ]; then
    # Set current group's working directory to PWD
    printf '\\033]1337;MasonCommand=set;Path=%s\\007' "$PWD"
  fi
}
# Source user's rc file if it exists
if [ -f ~/.bashrc ]; then source ~/.bashrc; fi
if [ -f ~/.zshrc ]; then source ~/.zshrc; fi
`;
        // Write init script to temp file
        const tmpDir = os.tmpdir();
        const initFile = path.join(tmpDir, `.mason_init_${terminalId}`);
        fs.writeFileSync(initFile, initScript);

        // Use --rcfile for bash, or ENV for other shells
        if (shellPath.includes('bash')) {
          shellArgs = ['--rcfile', initFile, '-i'];
        } else if (shellPath.includes('zsh')) {
          // For zsh, we need to preserve the user's actual ZDOTDIR and home
          const userHome = os.homedir();
          const originalZdotdir = env.ZDOTDIR || userHome;

          // Create a custom .zshenv that sources the user's real one first (for PATH)
          // then create .zshrc with mason function
          // zsh sources files in this order: .zshenv -> .zprofile -> .zshrc -> .zlogin

          const zshenvScript = `
# Source the user's actual .zshenv from their home directory first
# This is critical for PATH setup
if [ -f "$HOME/.zshenv" ]; then
  source "$HOME/.zshenv"
fi
`;

          const zshrcScript = `
mason() {
  if [ "$1" = "new-group" ]; then
    # Convert relative path to absolute path
    local abs_path
    if [[ "$2" = /* ]]; then
      # Already absolute
      abs_path="$2"
    else
      # Make it absolute relative to PWD
      abs_path="$(cd "$2" 2>/dev/null && pwd)" || abs_path="$PWD/$2"
    fi
    printf '\\033]1337;MasonCommand=new-group;Path=%s\\007' "$abs_path"
  elif [ "$1" = "set" ]; then
    # Set current group's working directory to PWD
    printf '\\033]1337;MasonCommand=set;Path=%s\\007' "$PWD"
  fi
}

# Source the user's actual .zprofile if it exists (more PATH setup)
if [ -f "$HOME/.zprofile" ]; then
  source "$HOME/.zprofile"
fi

# Source the user's actual .zshrc from their home directory
if [ -f "$HOME/.zshrc" ]; then
  source "$HOME/.zshrc"
fi
`;

          env.ZDOTDIR = tmpDir;
          const zshenv = path.join(tmpDir, '.zshenv');
          const zshrc = path.join(tmpDir, '.zshrc');
          fs.writeFileSync(zshenv, zshenvScript);
          fs.writeFileSync(zshrc, zshrcScript);

          // Start zsh as a login shell (-l) and interactive (-i)
          // This ensures .zprofile and other login files are sourced
          shellArgs = ['-l', '-i'];
        } else {
          // For other shells, just use default
          shellArgs = [];
        }
      }

      const ptyProcess = pty.spawn(shellPath, shellArgs, {
        name: 'xterm-color',
        cols: 80,
        rows: 24,
        cwd: actualWorkingDir,
        env: env,
      });

      ptyProcesses.set(terminalId, ptyProcess);

      // Send data from PTY to renderer
      ptyProcess.onData((data: string) => {
        // Check for mason commands in the output
        const masonCommand = parseMasonCommand(data);
        if (masonCommand) {
          console.log(`Mason command detected: ${masonCommand.command} ${masonCommand.path}`);
          // Send mason command to renderer
          BrowserWindow.getAllWindows()[0]?.webContents.send('mason:command', {
            command: masonCommand.command,
            path: masonCommand.path,
          });
        }

        // Strip mason commands from output before sending to terminal
        const cleanedData = stripMasonCommands(data);
        if (cleanedData) {
          BrowserWindow.getAllWindows()[0]?.webContents.send(`terminal:data:${terminalId}`, cleanedData);
        }
      });

      // Handle process exit
      ptyProcess.onExit(({ exitCode, signal }) => {
        console.log(`Terminal ${terminalId} exited with code ${exitCode}, signal ${signal}`);
        BrowserWindow.getAllWindows()[0]?.webContents.send(`terminal:exit:${terminalId}`, exitCode);
        ptyProcesses.delete(terminalId);

        // Clean up temp init file
        if (process.platform !== 'win32') {
          const tmpDir = os.tmpdir();
          const initFile = path.join(tmpDir, `.mason_init_${terminalId}`);
          const zshrc = path.join(tmpDir, '.zshrc');
          const zshenv = path.join(tmpDir, '.zshenv');
          try {
            fs.unlinkSync(initFile);
          } catch (e) {
            // Ignore if file doesn't exist
          }
          try {
            fs.unlinkSync(zshrc);
          } catch (e) {
            // Ignore if file doesn't exist
          }
          try {
            fs.unlinkSync(zshenv);
          } catch (e) {
            // Ignore if file doesn't exist
          }
        }
      });

      console.log(`=== TERMINAL CREATE SUCCESS ===`);
      console.log(`Terminal ${terminalId} created successfully`);
    } catch (error) {
      console.error(`=== TERMINAL CREATE FAILED ===`);
      console.error(`Failed to create terminal ${terminalId}:`);
      console.error(`Error name: ${error.name}`);
      console.error(`Error message: ${error.message}`);
      console.error(`Error stack:`, error.stack);
      if (error.code) console.error(`Error code: ${error.code}`);
      if (error.errno) console.error(`Error errno: ${error.errno}`);
      if (error.syscall) console.error(`Error syscall: ${error.syscall}`);
      throw error;
    }

    return { success: true };
  });

  // Handle input from renderer
  ipcMain.on('terminal:input', (_, terminalId: string, data: string) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (ptyProcess) {
      ptyProcess.write(data);
    }
  });

  // Handle resize
  ipcMain.on('terminal:resize', (_, terminalId: string, cols: number, rows: number) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (ptyProcess) {
      ptyProcess.resize(cols, rows);
    }
  });

  // Helper function to get all child PIDs recursively
  const getChildPids = async (parentPid: number): Promise<number[]> => {
    if (process.platform === 'win32') {
      return []; // Not implemented for Windows yet
    }

    try {
      // Use pgrep to find all descendants
      const { stdout } = await execAsync(`pgrep -P ${parentPid}`);
      const childPids = stdout
        .trim()
        .split('\n')
        .filter((line) => line)
        .map((pid) => parseInt(pid, 10));

      // Recursively get children of children
      const allDescendants: number[] = [...childPids];
      for (const childPid of childPids) {
        const descendants = await getChildPids(childPid);
        allDescendants.push(...descendants);
      }

      return allDescendants;
    } catch (error) {
      // No children found or pgrep failed
      return [];
    }
  };

  // Helper function to find gh executable
  const findGhExecutable = (): string => {
    // Common locations for gh CLI
    const commonPaths = [
      '/opt/homebrew/bin/gh',
      '/usr/local/bin/gh',
      '/usr/bin/gh',
    ];

    // Check if gh is in PATH first
    try {
      const { stdout } = require('child_process').execSync('which gh', { encoding: 'utf8' });
      const ghPath = stdout.trim();
      if (ghPath && fs.existsSync(ghPath)) {
        return ghPath;
      }
    } catch {
      // which command failed, continue to check common paths
    }

    // Check common paths
    for (const ghPath of commonPaths) {
      if (fs.existsSync(ghPath)) {
        return ghPath;
      }
    }

    // Fallback to just 'gh' and hope it's in PATH
    return 'gh';
  };

  // Get git branch for a directory
  ipcMain.handle('git:getBranch', async (_, workingDir: string) => {
    try {
      // Expand ~ to home directory
      let actualWorkingDir = workingDir;
      if (workingDir === '~' || workingDir.startsWith('~/')) {
        const home = os.homedir();
        if (workingDir === '~') {
          actualWorkingDir = home;
        } else {
          actualWorkingDir = home + workingDir.substring(1);
        }
      }

      // Check if directory exists
      if (!fs.existsSync(actualWorkingDir)) {
        return null;
      }

      // Execute git command to get current branch
      const { stdout } = await execAsync('git branch --show-current', {
        cwd: actualWorkingDir,
      });

      const branch = stdout.trim();
      return branch || null;
    } catch (error) {
      // Not a git repository or git command failed
      return null;
    }
  });

  // Get pull request for current branch
  ipcMain.handle('git:getPr', async (_, workingDir: string) => {
    try {
      // Expand ~ to home directory
      let actualWorkingDir = workingDir;
      if (workingDir === '~' || workingDir.startsWith('~/')) {
        const home = os.homedir();
        if (workingDir === '~') {
          actualWorkingDir = home;
        } else {
          actualWorkingDir = home + workingDir.substring(1);
        }
      }

      // Check if directory exists
      if (!fs.existsSync(actualWorkingDir)) {
        return null;
      }

      // Execute gh command to get PR for current branch
      // Include state to show open, merged, or closed PRs
      const ghPath = findGhExecutable();
      const { stdout } = await execAsync(`${ghPath} pr view --json number,title,url,state`, {
        cwd: actualWorkingDir,
      });

      const prData = JSON.parse(stdout.trim());
      if (prData && prData.number) {
        return {
          number: prData.number,
          title: prData.title,
          url: prData.url,
          state: prData.state || 'OPEN',
        };
      }
      return null;
    } catch (error) {
      // No PR for this branch, gh not installed, or not authenticated
      return null;
    }
  });

  // Get process information for a terminal
  ipcMain.handle('terminal:getProcessInfo', async (_, terminalId: string) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (!ptyProcess) {
      return null;
    }

    const pid = ptyProcess.pid;
    const processName = ptyProcess.process;

    try {
      // Get all child PIDs (including shell and its children)
      const allPids = [pid, ...(await getChildPids(pid))];

      // Get CPU and memory usage for all processes
      const statsPromises = allPids.map((p) =>
        pidusage(p).catch(() => null)
      );
      const allStats = await Promise.all(statsPromises);

      // Sum up CPU and memory across all processes
      let totalCpu = 0;
      let totalMemory = 0;
      allStats.forEach((stat) => {
        if (stat) {
          totalCpu += stat.cpu;
          totalMemory += stat.memory;
        }
      });

      // Get listening ports using lsof (Unix-like systems only)
      // Check all PIDs for listening ports
      let ports: number[] = [];
      if (process.platform !== 'win32') {
        try {
          const pidsString = allPids.join(',');
          const { stdout } = await execAsync(`lsof -Pan -p ${pidsString} -i`);
          const lines = stdout.split('\n');
          const portSet = new Set<number>();

          for (const line of lines) {
            // Look for LISTEN state and extract port
            if (line.includes('LISTEN')) {
              const match = line.match(/:(\d+)\s/);
              if (match) {
                portSet.add(parseInt(match[1], 10));
              }
            }
          }

          ports = Array.from(portSet).sort((a, b) => a - b);
        } catch (error) {
          // lsof might fail if process has no network connections
          // This is fine, just return empty ports array
        }
      }

      return {
        terminalId,
        pid,
        processName,
        ports,
        cpuPercent: Math.round(totalCpu * 10) / 10, // Round to 1 decimal
        memoryMB: Math.round(totalMemory / 1024 / 1024 * 10) / 10, // Convert to MB, round to 1 decimal
      };
    } catch (error) {
      console.error(`Failed to get process info for ${terminalId}:`, error);
      return {
        terminalId,
        pid,
        processName,
        ports: [],
        cpuPercent: 0,
        memoryMB: 0,
      };
    }
  });

  // Open URL in default browser
  ipcMain.handle('shell:openExternal', async (_, url: string) => {
    try {
      await shell.openExternal(url);
      return { success: true };
    } catch (error) {
      console.error('Failed to open URL:', error);
      return { success: false };
    }
  });

  // Detect installed editors
  ipcMain.handle('shell:detectInstalledEditors', async () => {
    const editors = [
      {
        id: 'code',
        name: 'Visual Studio Code',
        paths: ['/usr/local/bin/code', '/opt/homebrew/bin/code']
      },
      {
        id: 'cursor',
        name: 'Cursor',
        paths: ['/usr/local/bin/cursor', '/opt/homebrew/bin/cursor']
      },
    ];

    const installed = [];
    for (const editor of editors) {
      let editorPath = null;

      // Try common paths
      for (const path of editor.paths) {
        try {
          await fs.promises.access(path, fs.constants.X_OK);
          editorPath = path;
          break;
        } catch {
          // Not found at this path
        }
      }

      // If not found in common paths, try using 'which'
      if (!editorPath) {
        try {
          const { stdout } = await execAsync(`which ${editor.id}`);
          const commandPath = stdout.trim();
          if (commandPath) {
            editorPath = commandPath;
          }
        } catch {
          // Editor not found
        }
      }

      if (editorPath) {
        installed.push({ id: editor.id, name: editor.name, path: editorPath });
      }
    }

    return installed;
  });

  // Open directory in editor
  ipcMain.handle('shell:openInEditor', async (_, workingDir: string) => {
    try {
      const settings = await SettingsManager.load();
      const preferredEditor = settings.editor.preferredEditor;

      // If system default is selected, just open in Finder/File Explorer
      if (preferredEditor === 'system') {
        await shell.openPath(workingDir);
        return { success: true };
      }

      // List of editors with their possible paths
      const editors = [
        {
          id: 'code',
          paths: ['/usr/local/bin/code', '/opt/homebrew/bin/code']
        },
        {
          id: 'cursor',
          paths: ['/usr/local/bin/cursor', '/opt/homebrew/bin/cursor']
        },
      ];

      // Helper function to try opening with an editor
      const tryOpenEditor = async (editorId: string): Promise<boolean> => {
        const editor = editors.find(e => e.id === editorId);
        if (!editor) return false;

        // Try common paths
        for (const editorPath of editor.paths) {
          try {
            await fs.promises.access(editorPath, fs.constants.X_OK);
            await execAsync(`"${editorPath}" "${workingDir}"`);
            return true;
          } catch {
            // Try next path
          }
        }

        // Try with 'which' as fallback
        try {
          const { stdout } = await execAsync(`which ${editorId}`);
          const commandPath = stdout.trim();
          if (commandPath) {
            await execAsync(`"${commandPath}" "${workingDir}"`);
            return true;
          }
        } catch {
          // Not found
        }

        return false;
      };

      // If a specific editor is preferred, try it first
      if (preferredEditor !== 'auto') {
        const success = await tryOpenEditor(preferredEditor);
        if (success) {
          return { success: true };
        }
        console.error(`Preferred editor ${preferredEditor} not found or failed to open`);
      }

      // Auto mode or preferred editor failed - try all editors in order
      for (const editor of editors) {
        const success = await tryOpenEditor(editor.id);
        if (success) {
          return { success: true };
        }
      }

      // No editor found, fall back to opening in Finder/File Explorer
      await shell.openPath(workingDir);
      return { success: true };
    } catch (error) {
      console.error('Failed to open in editor:', error);
      return { success: false };
    }
  });

  // Workspace persistence handlers

  // Get the workspace directory path and ensure it exists
  const getWorkspaceDir = (): string => {
    const homeDir = os.homedir();
    const workspaceDir = path.join(homeDir, '.mason');

    // Create directory if it doesn't exist
    if (!fs.existsSync(workspaceDir)) {
      fs.mkdirSync(workspaceDir, { recursive: true });
    }

    return workspaceDir;
  };

  // Generate filename with timestamp
  const generateFilename = (): string => {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    const hours = String(now.getHours()).padStart(2, '0');
    const minutes = String(now.getMinutes()).padStart(2, '0');
    const seconds = String(now.getSeconds()).padStart(2, '0');

    return `workspace-${year}-${month}-${day}-${hours}-${minutes}-${seconds}.json`;
  };

  // Save workspace to file
  ipcMain.handle('workspace:save', async (_, data: WorkspaceData, existingFilename?: string | null): Promise<string> => {
    try {
      const workspaceDir = getWorkspaceDir();
      // If an existing filename is provided, update that file; otherwise create a new one
      const filename = existingFilename || generateFilename();
      const filepath = path.join(workspaceDir, filename);

      // Write the workspace data to file
      fs.writeFileSync(filepath, JSON.stringify(data, null, 2), 'utf-8');

      console.log(`Workspace saved: ${filepath}`);
      return filename;
    } catch (error) {
      console.error('Failed to save workspace:', error);
      throw error;
    }
  });

  // Load workspace from file
  ipcMain.handle('workspace:load', async (_, filename: string): Promise<WorkspaceData> => {
    try {
      const workspaceDir = getWorkspaceDir();
      const filepath = path.join(workspaceDir, filename);

      if (!fs.existsSync(filepath)) {
        throw new Error(`Workspace file not found: ${filename}`);
      }

      const content = fs.readFileSync(filepath, 'utf-8');
      const data: WorkspaceData = JSON.parse(content);

      console.log(`Workspace loaded: ${filepath}`);
      return data;
    } catch (error) {
      console.error('Failed to load workspace:', error);
      throw error;
    }
  });

  // List all available workspaces
  ipcMain.handle('workspace:list', async (): Promise<WorkspaceMetadata[]> => {
    try {
      const workspaceDir = getWorkspaceDir();

      // Read all files in the workspace directory
      const files = fs.readdirSync(workspaceDir);

      // Filter for workspace JSON files and extract metadata
      const workspaces: WorkspaceMetadata[] = files
        .filter(file => file.startsWith('workspace-') && file.endsWith('.json'))
        .map(filename => {
          const filepath = path.join(workspaceDir, filename);
          try {
            const content = fs.readFileSync(filepath, 'utf-8');
            const data: WorkspaceData = JSON.parse(content);

            return {
              filename,
              filepath,
              timestamp: data.timestamp,
              groupCount: data.groups.length,
              groupNames: data.groups.map(g => g.title),
            };
          } catch (error) {
            console.error(`Failed to parse workspace file ${filename}:`, error);
            return null;
          }
        })
        .filter((w): w is WorkspaceMetadata => w !== null);

      console.log(`Found ${workspaces.length} workspace(s)`);
      return workspaces;
    } catch (error) {
      console.error('Failed to list workspaces:', error);
      return [];
    }
  });

  // Settings handlers
  ipcMain.handle('settings:load', async (): Promise<AppSettings> => {
    try {
      const settings = await SettingsManager.load();
      console.log('Settings loaded');
      return settings;
    } catch (error) {
      console.error('Failed to load settings:', error);
      throw error;
    }
  });

  ipcMain.handle('settings:save', async (_, settings: AppSettings): Promise<void> => {
    try {
      await SettingsManager.save(settings);
      console.log('Settings saved');
    } catch (error) {
      console.error('Failed to save settings:', error);
      throw error;
    }
  });

  ipcMain.handle('settings:reset', async (): Promise<AppSettings> => {
    try {
      const settings = await SettingsManager.reset();
      console.log('Settings reset to defaults');
      return settings;
    } catch (error) {
      console.error('Failed to reset settings:', error);
      throw error;
    }
  });

  // Handle window close request
  ipcMain.on('window:close', () => {
    const mainWindow = BrowserWindow.getAllWindows()[0];
    if (mainWindow) {
      mainWindow.close();
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  setupTerminalHandlers();

  // Request Automation permissions on macOS (triggers system prompt if needed)
  await requestAutomationPermissions();

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
