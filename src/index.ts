import { app, BrowserWindow, ipcMain, shell } from 'electron';
import * as pty from 'node-pty';
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import pidusage from 'pidusage';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

// Request macOS Automation permissions proactively
const requestAutomationPermissions = async (): Promise<void> => {
  // Only run on macOS
  if (process.platform !== 'darwin') {
    return;
  }

  try {
    // Run a harmless osascript command that requires Automation permission
    // This will trigger the macOS permission prompt if not already granted
    await execAsync('osascript -e \'tell application "System Events" to return name\'');
    console.log('Automation permissions: granted or prompted');
  } catch (error) {
    // Permission denied or not yet granted
    // The error will be -1743 if permission is denied
    console.log('Automation permissions: awaiting user approval');
    // Don't block app startup - user can grant permission later
  }
};

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Store PTY instances for multiple terminals
const ptyProcesses = new Map<string, pty.IPty>();

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development mode only
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }
};

// Setup IPC handlers for terminal - must be before window creation
const setupTerminalHandlers = () => {
  // Determine shell based on OS
  let shellPath = process.platform === 'win32' ? 'powershell.exe' : process.env.SHELL || '/bin/zsh';

  // Validate shell exists
  if (process.platform !== 'win32') {
    const commonShells = [shellPath, '/bin/zsh', '/bin/bash', '/bin/sh'];
    shellPath = '';
    for (const testShell of commonShells) {
      if (fs.existsSync(testShell)) {
        shellPath = testShell;
        break;
      }
    }
    if (!shellPath) {
      shellPath = '/bin/sh'; // Ultimate fallback
    }
  }

  // Helper function to parse mason escape sequences from terminal output
  const parseMasonCommand = (data: string): { command: string; path: string } | null => {
    // Match OSC 1337 escape sequence: ESC ] 1337 ; MasonCommand=new-group ; Path=<path> BEL
    const match = data.match(/\x1b\]1337;MasonCommand=([^;]+);Path=([^\x07\x1b]+)[\x07\x1b]/);
    if (match) {
      return { command: match[1], path: match[2] };
    }
    return null;
  };

  // Helper function to strip mason escape sequences from output
  const stripMasonCommands = (data: string): string => {
    return data.replace(/\x1b\]1337;MasonCommand=[^;]+;Path=[^\x07\x1b]+[\x07\x1b]/g, '');
  };

  // Create terminal process
  ipcMain.handle('terminal:create', (_, terminalId: string, workingDir: string) => {
    // Clean up existing process if it exists
    if (ptyProcesses.has(terminalId)) {
      ptyProcesses.get(terminalId)?.kill();
      ptyProcesses.delete(terminalId);
    }

    // Expand ~ to home directory
    let actualWorkingDir = workingDir;
    if (workingDir === '~' || workingDir.startsWith('~/')) {
      const home = os.homedir();
      if (workingDir === '~') {
        actualWorkingDir = home;
      } else {
        actualWorkingDir = home + workingDir.substring(1);
      }
    }

    // Verify the directory exists and is accessible
    if (!fs.existsSync(actualWorkingDir)) {
      // Fallback to home directory
      actualWorkingDir = os.homedir();
    }

    try {
      // Prepare environment with PROMPT_COMMAND or precmd for bash/zsh
      const env = { ...(process.env as { [key: string]: string }) };

      // For bash/zsh, we'll use shell arguments to source the mason function
      let shellArgs: string[] = [];
      if (process.platform !== 'win32') {
        // For bash/zsh, use --init-file or --rcfile to inject our function
        // We'll write the function definition and then source the normal rc file
        const initScript = `
mason() {
  if [ "$1" = "new-group" ]; then
    # Convert relative path to absolute path
    local abs_path
    if [[ "$2" = /* ]]; then
      # Already absolute
      abs_path="$2"
    else
      # Make it absolute relative to PWD
      abs_path="$(cd "$2" 2>/dev/null && pwd)" || abs_path="$PWD/$2"
    fi
    printf '\\033]1337;MasonCommand=new-group;Path=%s\\007' "$abs_path"
  elif [ "$1" = "set" ]; then
    # Set current group's working directory to PWD
    printf '\\033]1337;MasonCommand=set;Path=%s\\007' "$PWD"
  fi
}
# Source user's rc file if it exists
if [ -f ~/.bashrc ]; then source ~/.bashrc; fi
if [ -f ~/.zshrc ]; then source ~/.zshrc; fi
`;
        // Write init script to temp file
        const tmpDir = os.tmpdir();
        const initFile = path.join(tmpDir, `.mason_init_${terminalId}`);
        fs.writeFileSync(initFile, initScript);

        // Use --rcfile for bash, or ENV for other shells
        if (shellPath.includes('bash')) {
          shellArgs = ['--rcfile', initFile, '-i'];
        } else if (shellPath.includes('zsh')) {
          // For zsh, we need to preserve the user's actual ZDOTDIR and home
          const userHome = os.homedir();
          const originalZdotdir = env.ZDOTDIR || userHome;

          // Create a custom .zshenv that sources the user's real one first (for PATH)
          // then create .zshrc with mason function
          // zsh sources files in this order: .zshenv -> .zprofile -> .zshrc -> .zlogin

          const zshenvScript = `
# Source the user's actual .zshenv from their home directory first
# This is critical for PATH setup
if [ -f "$HOME/.zshenv" ]; then
  source "$HOME/.zshenv"
fi
`;

          const zshrcScript = `
mason() {
  if [ "$1" = "new-group" ]; then
    # Convert relative path to absolute path
    local abs_path
    if [[ "$2" = /* ]]; then
      # Already absolute
      abs_path="$2"
    else
      # Make it absolute relative to PWD
      abs_path="$(cd "$2" 2>/dev/null && pwd)" || abs_path="$PWD/$2"
    fi
    printf '\\033]1337;MasonCommand=new-group;Path=%s\\007' "$abs_path"
  elif [ "$1" = "set" ]; then
    # Set current group's working directory to PWD
    printf '\\033]1337;MasonCommand=set;Path=%s\\007' "$PWD"
  fi
}

# Source the user's actual .zprofile if it exists (more PATH setup)
if [ -f "$HOME/.zprofile" ]; then
  source "$HOME/.zprofile"
fi

# Source the user's actual .zshrc from their home directory
if [ -f "$HOME/.zshrc" ]; then
  source "$HOME/.zshrc"
fi
`;

          env.ZDOTDIR = tmpDir;
          const zshenv = path.join(tmpDir, '.zshenv');
          const zshrc = path.join(tmpDir, '.zshrc');
          fs.writeFileSync(zshenv, zshenvScript);
          fs.writeFileSync(zshrc, zshrcScript);

          // Start zsh as a login shell (-l) and interactive (-i)
          // This ensures .zprofile and other login files are sourced
          shellArgs = ['-l', '-i'];
        } else {
          // For other shells, just use default
          shellArgs = [];
        }
      }

      const ptyProcess = pty.spawn(shellPath, shellArgs, {
        name: 'xterm-color',
        cols: 80,
        rows: 24,
        cwd: actualWorkingDir,
        env: env,
      });

      ptyProcesses.set(terminalId, ptyProcess);

      // Send data from PTY to renderer
      ptyProcess.onData((data: string) => {
        // Check for mason commands in the output
        const masonCommand = parseMasonCommand(data);
        if (masonCommand) {
          console.log(`Mason command detected: ${masonCommand.command} ${masonCommand.path}`);
          // Send mason command to renderer
          BrowserWindow.getAllWindows()[0]?.webContents.send('mason:command', {
            command: masonCommand.command,
            path: masonCommand.path,
          });
        }

        // Strip mason commands from output before sending to terminal
        const cleanedData = stripMasonCommands(data);
        if (cleanedData) {
          BrowserWindow.getAllWindows()[0]?.webContents.send(`terminal:data:${terminalId}`, cleanedData);
        }
      });

      // Handle process exit
      ptyProcess.onExit(({ exitCode, signal }) => {
        console.log(`Terminal ${terminalId} exited with code ${exitCode}, signal ${signal}`);
        BrowserWindow.getAllWindows()[0]?.webContents.send(`terminal:exit:${terminalId}`, exitCode);
        ptyProcesses.delete(terminalId);

        // Clean up temp init file
        if (process.platform !== 'win32') {
          const tmpDir = os.tmpdir();
          const initFile = path.join(tmpDir, `.mason_init_${terminalId}`);
          const zshrc = path.join(tmpDir, '.zshrc');
          const zshenv = path.join(tmpDir, '.zshenv');
          try {
            fs.unlinkSync(initFile);
          } catch (e) {
            // Ignore if file doesn't exist
          }
          try {
            fs.unlinkSync(zshrc);
          } catch (e) {
            // Ignore if file doesn't exist
          }
          try {
            fs.unlinkSync(zshenv);
          } catch (e) {
            // Ignore if file doesn't exist
          }
        }
      });

      console.log(`=== TERMINAL CREATE SUCCESS ===`);
      console.log(`Terminal ${terminalId} created successfully`);
    } catch (error) {
      console.error(`=== TERMINAL CREATE FAILED ===`);
      console.error(`Failed to create terminal ${terminalId}:`);
      console.error(`Error name: ${error.name}`);
      console.error(`Error message: ${error.message}`);
      console.error(`Error stack:`, error.stack);
      if (error.code) console.error(`Error code: ${error.code}`);
      if (error.errno) console.error(`Error errno: ${error.errno}`);
      if (error.syscall) console.error(`Error syscall: ${error.syscall}`);
      throw error;
    }

    return { success: true };
  });

  // Handle input from renderer
  ipcMain.on('terminal:input', (_, terminalId: string, data: string) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (ptyProcess) {
      ptyProcess.write(data);
    }
  });

  // Handle resize
  ipcMain.on('terminal:resize', (_, terminalId: string, cols: number, rows: number) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (ptyProcess) {
      ptyProcess.resize(cols, rows);
    }
  });

  // Helper function to get all child PIDs recursively
  const getChildPids = async (parentPid: number): Promise<number[]> => {
    if (process.platform === 'win32') {
      return []; // Not implemented for Windows yet
    }

    try {
      // Use pgrep to find all descendants
      const { stdout } = await execAsync(`pgrep -P ${parentPid}`);
      const childPids = stdout
        .trim()
        .split('\n')
        .filter((line) => line)
        .map((pid) => parseInt(pid, 10));

      // Recursively get children of children
      const allDescendants: number[] = [...childPids];
      for (const childPid of childPids) {
        const descendants = await getChildPids(childPid);
        allDescendants.push(...descendants);
      }

      return allDescendants;
    } catch (error) {
      // No children found or pgrep failed
      return [];
    }
  };

  // Get git branch for a directory
  ipcMain.handle('git:getBranch', async (_, workingDir: string) => {
    try {
      // Expand ~ to home directory
      let actualWorkingDir = workingDir;
      if (workingDir === '~' || workingDir.startsWith('~/')) {
        const home = os.homedir();
        if (workingDir === '~') {
          actualWorkingDir = home;
        } else {
          actualWorkingDir = home + workingDir.substring(1);
        }
      }

      // Check if directory exists
      if (!fs.existsSync(actualWorkingDir)) {
        return null;
      }

      // Execute git command to get current branch
      const { stdout } = await execAsync('git branch --show-current', {
        cwd: actualWorkingDir,
      });

      const branch = stdout.trim();
      return branch || null;
    } catch (error) {
      // Not a git repository or git command failed
      return null;
    }
  });

  // Get pull request for current branch
  ipcMain.handle('git:getPr', async (_, workingDir: string) => {
    try {
      // Expand ~ to home directory
      let actualWorkingDir = workingDir;
      if (workingDir === '~' || workingDir.startsWith('~/')) {
        const home = os.homedir();
        if (workingDir === '~') {
          actualWorkingDir = home;
        } else {
          actualWorkingDir = home + workingDir.substring(1);
        }
      }

      // Check if directory exists
      if (!fs.existsSync(actualWorkingDir)) {
        return null;
      }

      // Execute gh command to get PR for current branch
      const { stdout } = await execAsync('gh pr view --json number,title,url', {
        cwd: actualWorkingDir,
      });

      const prData = JSON.parse(stdout.trim());
      if (prData && prData.number) {
        return {
          number: prData.number,
          title: prData.title,
          url: prData.url,
        };
      }
      return null;
    } catch (error) {
      // No PR for this branch, gh not installed, or not authenticated
      return null;
    }
  });

  // Get process information for a terminal
  ipcMain.handle('terminal:getProcessInfo', async (_, terminalId: string) => {
    const ptyProcess = ptyProcesses.get(terminalId);
    if (!ptyProcess) {
      return null;
    }

    const pid = ptyProcess.pid;
    const processName = ptyProcess.process;

    try {
      // Get all child PIDs (including shell and its children)
      const allPids = [pid, ...(await getChildPids(pid))];

      // Get CPU and memory usage for all processes
      const statsPromises = allPids.map((p) =>
        pidusage(p).catch(() => null)
      );
      const allStats = await Promise.all(statsPromises);

      // Sum up CPU and memory across all processes
      let totalCpu = 0;
      let totalMemory = 0;
      allStats.forEach((stat) => {
        if (stat) {
          totalCpu += stat.cpu;
          totalMemory += stat.memory;
        }
      });

      // Get listening ports using lsof (Unix-like systems only)
      // Check all PIDs for listening ports
      let ports: number[] = [];
      if (process.platform !== 'win32') {
        try {
          const pidsString = allPids.join(',');
          const { stdout } = await execAsync(`lsof -Pan -p ${pidsString} -i`);
          const lines = stdout.split('\n');
          const portSet = new Set<number>();

          for (const line of lines) {
            // Look for LISTEN state and extract port
            if (line.includes('LISTEN')) {
              const match = line.match(/:(\d+)\s/);
              if (match) {
                portSet.add(parseInt(match[1], 10));
              }
            }
          }

          ports = Array.from(portSet).sort((a, b) => a - b);
        } catch (error) {
          // lsof might fail if process has no network connections
          // This is fine, just return empty ports array
        }
      }

      return {
        terminalId,
        pid,
        processName,
        ports,
        cpuPercent: Math.round(totalCpu * 10) / 10, // Round to 1 decimal
        memoryMB: Math.round(totalMemory / 1024 / 1024 * 10) / 10, // Convert to MB, round to 1 decimal
      };
    } catch (error) {
      console.error(`Failed to get process info for ${terminalId}:`, error);
      return {
        terminalId,
        pid,
        processName,
        ports: [],
        cpuPercent: 0,
        memoryMB: 0,
      };
    }
  });

  // Open URL in default browser
  ipcMain.handle('shell:openExternal', async (_, url: string) => {
    try {
      await shell.openExternal(url);
      return { success: true };
    } catch (error) {
      console.error('Failed to open URL:', error);
      return { success: false };
    }
  });

  // Open directory in editor
  ipcMain.handle('shell:openInEditor', async (_, workingDir: string) => {
    try {
      // Try common editors in order of preference
      const editors = [
        { command: 'code', args: [workingDir] },           // VS Code
        { command: 'cursor', args: [workingDir] },         // Cursor
        { command: 'subl', args: [workingDir] },           // Sublime Text
        { command: 'atom', args: [workingDir] },           // Atom
      ];

      for (const editor of editors) {
        try {
          await execAsync(`which ${editor.command}`);
          // Editor found, open it
          await execAsync(`${editor.command} "${workingDir}"`);
          return { success: true };
        } catch {
          // Editor not found, try next
          continue;
        }
      }

      // No editor found, fall back to opening in Finder/File Explorer
      await shell.openPath(workingDir);
      return { success: true };
    } catch (error) {
      console.error('Failed to open in editor:', error);
      return { success: false };
    }
  });

  // Handle window close request
  ipcMain.on('window:close', () => {
    const mainWindow = BrowserWindow.getAllWindows()[0];
    if (mainWindow) {
      mainWindow.close();
    }
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', async () => {
  setupTerminalHandlers();

  // Request Automation permissions on macOS (triggers system prompt if needed)
  await requestAutomationPermissions();

  createWindow();
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
